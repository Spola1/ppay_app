## Запуск локально


```bash
bundle
bin/setup
bin/dev
```

## Запуск в докере

#### Подготовка проекта

Создать `.env` и `.env.dev`

```bash
touch ppay_app/.env
cp ppay_app/.env.dev.example ppay_app/.env.dev
```

Сбилдить базовый образ (билдится один раз, потом можно изредка обновлять, если добавится много гемов)

```bash
docker build --build-arg BUNDLE_PATH=/bundle -f ppay_app/Dockerfile.base -t ppay_app_base ppay_app
```

#### Заупск контейнеров

```bash
docker-compose -f docker-compose-dev.yml up --build
```

---

### Как зайти в:

#### Работающий контейнер

```bash
docker-compose exec app bash
```

#### Консоль

```bash
docker-compose exec app bin/rails c
```

#### Логи `sidekiq`

```bash
docker-compose logs worker
```

## Основные сценарии работы приложения

### Обработка платежей

#### Депозит (`Deposit`)

1. Мерчант (магазин) по API создаёт новый платёж у нас в системе

	Создание платежа можно имитировать через `Swagger`, для этого нужно:
	*  Зайти на `/api-docs`
	*  Логин/пароль от basic авторизации лежит в config/settings.yml - basic_auth
	*  Нажать кнопку **Authorize** и ввести API-ключ мерчанта
	*  API-ключ можно получить в консоли `Merchant.last.api_keys.last.token`
	*  Развернуть API-метод `POST /api/v1/payments/deposits`
	*  Нажать **Try it out**
	*  Нажать **Execute**
	*  В ответ придёт `uuid` и ссылка на платёж
2. Мерчант даёт клиенту ссылку на оплату, которую получил по API в ответ
3. Клиент переходит по ссылке (лучше переходить в отдельном окне инкогнито или в другом браузере, чтобы не быть авторизованным в системе), выбирает платёжную систему (банк, на который будет переводить деньги)
4. Начинается поиск оператора для получения и обработки платежа
	
	**Важно:** чтобы нашёлся оператор, нужно:

	* Чтобы в системе был курс выбранной валюты к USDT `RateSnapshot`

		Если нет, запускаем:

		```ruby
		RateSnapshots::GetAllRatesJob.new.perform
		```

	* Чтобы в системе был юзер с ролью `Processer`
	* Чтобы у него на балансе было достаточно USDT по последнему курсу
	* Чтобы у него было активное объявление `Advertisement`,  поле `status: true`, с аналогичной платёжной системой

5. У оператора замораживаются деньги на балансе, платёж переходит в статус **Перевод денег**, у клиента появляется окно с картой оператора, на которую он должен перевести деньги
6. Клиент переводит деньги, загружает чек/скриншот
7. У оператора в системе появляется платёж в статусе **Подтверждение**, где он должен нажать кнопку **Подтвердить**, в случае если всё ок, либо отправить платёж на арбитраж
8. Если оператор подтвердил, платёж успешно завершён

#### Вывод средств (`Withdrawal`)

1. Мерчант (магазин) по API создаёт новый платёж у нас в системе

	Создание платежа можно имитировать через `Swagger`, API-метод `POST /api/v1/payments/withdrawals` ([инструкция](#депозит-deposit))
2. Мерчант даёт клиенту ссылку на получение денег через нашу систему, которую получил по API в ответ
3. Клиент переходит по ссылке (лучше переходить в отдельном окне инкогнито или в другом браузере, чтобы не быть авторизованным в системе), выбирает платёжную систему (банк, на который будет переводить деньги) и вводит номер карты
4. Начинается поиск оператора для обработки и выплаты денег
	
	**Важно:** чтобы нашёлся оператор, нужно:

	* Чтобы в системе был курс выбранной валюты к USDT `RateSnapshot`

		Если нет, запускаем:

		```ruby
		RateSnapshots::GetAllRatesJob.new.perform
		```

	* Чтобы у мерчанта, инициировавшего платёж по API, на балансе было достаточно USDT по последнему курсу
	* Чтобы в системе был юзер с ролью `Processer`
	* Чтобы у него было активное объявление `Advertisement`,  поле `status: true`, с аналогичной платёжной системой

5. У мерчанта замораживаются деньги на балансе, платёж переходит в статус **Перевод денег**, у оператора появляется платёж с картой клиента, на которую он должен перевести деньги
6. Оператор переводит деньги, загружает чек/скриншот
7. У клиента появляется кнопка **Подтвердить**, которую он нажмёт когда получил деньги
8. Если клиент подтвердил, платёж успешно завершён


## Примечания и комментарии

#### По контейнеру `cron`:

`cron` запускает `perform_async` и этим кладёт сообщение в `redis`.
Потом в отдельном контейнере `worker` выполняются задачи с помощью `sidekiq`.

В контейнере `cron` логи самого `cron` не видно, они лежат отдельно.

В контейнер `sidekiq` попадают воркеры и с сервера, и с крона.